Un programa debe tener al menos 3 capas. controller, service y repository
el repositorio también es conocido como dao (Data transfer object) y se conecta con la base de datos

La aplicación es spring funciona con java y la base de datos puede ser cualquier otro tipo de modelo ie mysql postgress etc (dialecto)
para comunicar se necesita un interprete para que puedan comunicarse. Por ejemplo una computadora necesita un driver
para hablar con una impresora. 
de igual forma una app java necesita usar un driver para conectarse a una base de datos. 
El driver es una dependencia que se registra en el archivo pom.xml

Hace muchos años existía un problema con las bases de datos relacionales. El paradigma entidad relacion es intrínsecamente
incompatible con el paradigma orientado a objetos. Existía el jdbc (java database conection) y con 
sentencias sql desde el programa. 

De ahí nace el ORM (Object relational mapping), vincular objetos con tablas. Se puede mapear todo elemento de base de datos.
Existe un conjunto de especificaciones para llegar a esto. Uno de los mas conocidos es el JPA (Jakarta persistance API)
Existe un conjunto de ORMs en el mercado, entre estos esta hibernate, Eclipse link, Spring data 

hibernate pasa a ser un traductor. Se encarga de traducir codigo java a la estructura de la base de datos. Se dice que es 
independiente. 


aplication.properties es el archivo donde se configura toda la aplicación incluyendo las conexiones de las bases de datos  

pa2almp Nombre de la base de datos

estu_(valor) "estu_ " es un identificador de tabla

en cada linea se pone clave-valor, la clave va a ser un atributo fijo 

DDL auto none que el modelo que esta en la aplicacion no cree objetos en la base de datos. 

-----------------------------------------------------------------------------------------------------------------------------------

ANOTACIONES DE JAKARTA PERSISTANCE 

Un objeto representa una tabla. se le dice mediante anotacion @Table

    @Table(name="estudiante")
    @Table(name="estudiante", schema="") Para cambiar el esquema 
    @Entity

Cuando se mapea una tabla a traves de objetos, ese objeto pasa a ser entidad, la clase que mapeo la tabla
Una tabla esta compuesta de columnas (atributos de la clase) se maneja
con la anotacion @Column 

@Column(name = "estu_nombre")

Si ddl auto esta en none y el nombre del atributo y la columna no 
son los mismos, da error 

@Id identifica la clave primaria

El crud basico debe buscar y eliminar por un identificador 

Existe una interfaz que permite comuinicarse con la base de datos
ENTITY MANAGER manejador de entidades. esta interfaz es el componente
principal para interactuar con la base de datos. 
El driver solo permite la coneccion desde la aplicacion a la 
base de datos, no es bidireccional. 

NO LLEVA @Autowired
El entity manager debe tener una anotacion @PersistenceContext
y la clase repository debe tener la anotacion @Transactional

Para el crud existen metodos predefinidos. 


--------------------------taller 14-------------------------------

buena practica usar un valor secuencial como primary key en las 
tablas. 

Una secuencia en base de datos es asignar un valor secuencial a 
un registro de una base de datos. Esta secuencia no la visualiza
el usuario. Es un valor que se usa para la integridad referencial

para la secuencia 
@SequenceGenerator(name = "nombre_generador",sequenceName = "sec_estudiante",allocationSize = 1)

para indicar que es un valor generado 
@GeneratedValue(generator = "nombre_generador",strategy = GenerationType.SEQUENCE )

Estas anotaciones pueden estar en cualquier orden mientras esten 
arriba del valor secuencial 

select nextval ('sec_estudiante')


-------------------------------------------Taller 15 y 16 -----------------------------------
Los sistemas empresariales no tienen una sola entidad, estas pueden estar
relacionadas.

Relacion one to one: Un registro esta relacionado con un solo registro
este tipo de relacion se puede ver como dividir una tabla por un critero
ej 

Sea la tabla
Empleado{nombre, apellido, cedula, sueldo, cargo, horario}

se puede agrupar como

Ciudadano{nombre, apellido, cedula}
Empleado{sueldo, cargo, horario}

si una sola tabla tiene muchos campos nulos se la divide. 

otro concepto importante es que siemprew hay una tabla principal. se puede 
diferenciar considerando que tabla no puede dejar de existir

ej ciudadano puede existir sin empleado pero empleado no puede existir sin
ciudadano, por lo tanto ciudadano es la tabla principal. 

la tabla principal es importante porque su primary key baja como foreing key
a la tabla secundaria. Eso obedece a lo siguiente si no tengo un dato pk 
no rengo un fk y por lo tanto el registro no puede existir en la tabla
secundaria. (poner null es un error)

PARA PRUEBAS Y EXAMENES
ddl-auto = update compara el esquema de la base datos con lo que esta
mapeado en la aplicacion y si no coincide modifica la base para que sirva

Cuando no se da el nombre de @Table la tablña soje el mismo nombre de la clase

Si yo tengo una relacion 1 a 1 el ciudadano tiene una referencia a 
una referencia hacia empleado 

----------------------------------------------taller 17

@OneToOne(cascade = CascadeType.ALL) el momento que se va a insertar el empleado la alicacion inserta en cascada a ese 
atributo. se puede especificar si se ejecuta en cascad el create, read PERSIST, update  MERGE , delete REMOVE . ALL para todo
se debe var la confircacion del sistema para decidir que service usar, el de la tabla principal o la secundaria. 
Lo mas comun es que no se inserten ciudadanos si no que se busque en una base ya exitente y crear ls empleados con esa informacion. 

lo correcto es hacer los set en la capa service, no la controller. 


@OneToMany(mappedBy = "hotel" )
relacon uno a muchos, un registro en una tabla puede tener muchos registros en otra enlazados por una foreing key
un ejemplo es fatura:detalle hotel:habitacion 

un hotel pude tener muchas habitaciones pero una habitacion solo puede existir en un hotel. 

si un atributo no va a realizar operaciones matematicas deberia ser un string.



---------------------------------taller 18
muchos a muchos. la tabla principal no es mandatoria. 
se usan tablas de rompimiento
CascadeType.All se ejecuta en cascada la accion 

----------------------------------taller19

QUERY TYPES JPA




















































